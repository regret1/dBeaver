-- CREATE
-- 테이블 생성

CREATE TABLE MEMBER (
	MEMBER_NO NUMBER,
	MEMBER_ID VARCHAR2(20),
	MEMBER_PWD VARCHAR2(20),
	MEMBER_NAME VARCHAR2(15)
);
SELECT * FROM MEMBER;
DROP TABLE MEMBER;

--데이터 사전
-- 현재 계정의 테이블 목록
SELECT * FROM USER_TABLES;
-- 컬럼들의 목록
SELECT * FROM USER_TAB_COLUMNS WHERE TABLE_NAME = 'MEMBER';

-- 제약조건
-- NOT NULL
-- 'NULL 값 허용하지 않겠다'
-- 반드시 값을 기록해야 하는 컬럼에 해당 제약조건을 등록.
-- INSERT/UPDATE/DELETE 시에 NULL값을 허용하지 않도록 등록.

CREATE TABLE USER_NOCONS(
	USER_NO NUMBER,
	USER_ID VARCHAR2(20),
	USER_PWD VARCHAR2(20),
	USER_NAME VARCHAR2(15)
);	
SELECT* FROM USER_NOCONS;

-- 테이블에 값 추가하기
-- INSERT => DML
INSERT INTO USER_NOCONS VALUES(1, 'USER01','PASS01','이창진');
SELECT* FROM USER_NOCONS;

INSERT INTO USER_NOCONS VALUES(2,NULL,NULL,NULL);

CREATE TABLE USER_NOT_NULL(
	USER_NO NUMBER NOT NULL,
	USER_ID VARCHAR2(20) NOT NULL,
	USER_PWD VARCHAR2(20) NOT NULL,
	USER_NAME VARCHAR2(15)
);
SELECT* FROM USER_NOT_NULL;

INSERT INTO USER_NOT_NULL VALUES(1,'USER01','PASS01','이창진');
INSERT INTO USER_NOT_NULL VALUES(2,NULL,NULL,NULL);
INSERT INTO USER_NOT_NULL VALUES(2,'USER02','PASS02',NULL);



-- UNIQUE --
-- 중복을 허용하지 않는 제약조건
-- 컬럼에 값을 입력/ 수정 할때 중복 확인하여
-- 만약 값이 있을 경우 값을 수정 및 추가를 못하게 하는 제약조건

INSERT INTO USER_NOCONS VALUES(1, 'USER01', 'PASS01', '김창진');
SELECT* FROM USER_NOCONS;

CREATE TABLE USER_UNIQUE(
	USER_NO NUMBER,
	USER_ID VARCHAR2(20) UNIQUE, --컬럼 레벨 제약조건
	USER_PWD VARCHAR2(20),
	USER_NAME VARCHAR2(15)
);
SELECT*FROM USER_UNIQUE;
DROP TABLE USER_UNIQUE;

INSERT INTO USER_UNIQUE
VALUES(1,'USER01','PASS01','이창진');

-- ID만 다르게 해서 INSERT를 실행
-- 에러 없이 추가
INSERT INTO USER_UNIQUE
VALUES(1,'USER02','PASS01','이창진');

SELECT *
FROM USER_CONSTRAINTS C1
JOIN USER_CONS_COLUMNS C2 ON (C1.CONSTRAINT_NAME = C2.CONSTRAINT_NAME)
WHERE C1.TABLE_NAME = 'USER_NOT_NULL';


--CONS TYPE
-- P: PRIMARY KEY
-- C: CHECK, NOT NULL
-- U: UNIQUE
-- R:FOREIGN KEY(REFERENCE)

CREATE TABLE USER_UNIQUE2(
	USER_NO NUMBER,
	USER_ID VARCHAR2(20),
	USER_PWD VARCHAR2(30),
	USER_NAME VARCHAR2(15),
	UNIQUE(USER_ID) -- 컬럼이 모두 작성된 후 별도로 작성하는 제약조건
					-- 테이블 레벨 제약조건이라 한다.
);

INSERT INTO USER_UNIQUE2 VALUES(1,'USER01','PASS01','이창진');
INSERT INTO USER_UNIQUE2 VALUES(1,'USER01','PASS01','이창진');
SELECT * FROM USER_UNIQUE2;

-- UNIQUE 제약조건을 여러 개 컬럼에 적용하기
-- 두 개 이상의 컬럼을 하나의 제약조건으로 묶자
-- 테이블 레벨에서 선언.
-- D1 10
-- D1 20
-- D2 10
-- D2 20
-- D3 10
-- D3 20

CREATE TABLE USER_UNIQUE3(
	USER_NO NUMBER,
	USER_ID VARCHAR2(20),
	USER_PWD VARCHAR2(30),
	USER_NAME VARCHAR2(15),
	UNIQUE(USER_NO,USER_ID)
	-- 두 개 이상의 컬럼값을 중복되지 않게 설정하기
);

SELECT * FROM USER_UNIQUE3;

INSERT INTO USER_UNIQUE3 VALUES(1,'USER01','PASS01','이창진');
INSERT INTO USER_UNIQUE3 VALUES(1,'USER02','PASS02','이창진');

INSERT INTO USER_UNIQUE3 VALUES(2,'USER01','PASS03','박창진');


-- 제약조건에 이름 설정
CREATE TABLE CONS_NAME(
	TEST_DATA1 NUMBER CONSTRAINT NN_DATA1 NOT NULL,
	TEST_DATA2 VARCHAR2(30) CONSTRAINT UN_DATA1 UNIQUE,
	TEST_DATA3 VARCHAR2(20),
	CONSTRAINT UK_DATA3 UNIQUE(TEST_DATA3)
);
DROP TABLE CONS_NAME;
SELECT* FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'CONS_NAME';

SELECT * FROM CONS_NAME;

-- CHECK --
-- 컬럼에 값을 기록할 때 지정한 값 이외에는 값이
-- 저장 되지 않도록 범위를 제한하는 조건
CREATE TABLE USER_CHECK(
	USER_NO NUMBER,
	USER_ID VARCHAR2(20),
	USER_PWD VARCHAR2(30),
	USER_NAME VARCHAR2(15),
	GENDER CHAR(3) CHECK(GENDER IN ('남','여'))
);

SELECT * FROM USER_CHECK;

INSERT INTO USER_CHECK VALUES(1, 'USER01', 'PASS01', '홍길동','여');

-- 체크 제약조건 위배
INSERT INTO USER_CHECK VALUES(2,'USER02','PASS02','김길동','김');
INSERT INTO USER_CHECK VALUES(2,'USER02','PASS02','김길동','F');

INSERT INTO USER_CHECK VALUES(2,'USER02','PASS02','김길동','남');

-- CHECK 제약조건에 부등호 처리
CREATE TABLE USER_CHECK2(
	TEST_DATA NUMBER,
	CONSTRAINT CK_TEST_DATA CHECK(TEST_DATA > 0)
);

INSERT INTO USER_CHECK2 VALUES(10);
SELECT* FROM USER_CHECK2;

INSERT INTO USER_CHECK2 VALUES(-10);

CREATE TABLE USER_CHECK3(
	PRICE NUMBER,
	GRADE CHAR(1),
	CONTRAINT CK_USER_CHECK3_PRICE CHECK(PRICE BETWEEN 1 AND 99999),
	CHECK(GRADE >= 'A' AND GRADE <='F')
);

-- 한 컬럼에 제약 조건 여러개를 설정하기
CREATE TABLE TEST_DUAL_CONS(
	TST_NO NUMBER NOT NULL UNIQUE
);
SELECT * FROM USER_CONS_COLUMNS
WHERE TABLE_NAME = 'TEST_DUAL_CONS';

-- PRIMARY KEY 제약조건 --
-- '기본키 제약조건'
-- 테이블 내의 데이터들 중에서 한행을 식별하기 위한 고유값
-- 테이블 전체에 대한 각 데이터(ROW)의 식별자 역할을 수행시키는 제약조건.
-- NOT NULL과 UNIQUE 제약 조건이 부여.
-- 값이 반드시 들어가고, 중복이 있어서도 안된다.

-- 테이블마다 기본키는 하나만 존재.(하나의 컬럼에만 기본키 제약조건을 설정가능)
-- PRIMARY KEY는 한 컬럼에 적용가능하고, 여러 컬럼을 묶어서도 적용가능.

CREATE TABLE USER_PK_TABLE(
	USER_NO NUMBER CONSTRAINT PK_USER_NO PRIMARY KEY,
	USER_ID VARCHAR2(20) UNIQUE NOT NULL,
	USER_PWD VARCHAR2(30) NOT NULL,
	USER_NAME VARCHAR2(15) NOT NULL,
	GENDER VARCHAR2(3) CHECK(GENDER IN ('남','여'))
);

SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'USER_PK_TABLE';

INSERT INTO USER_PK_TABLE
VALUES(1,'USER01','PASS01','이창진','남');

SELECT * FROM USER_PK_TABLE;

INSERT INTO USER_PK_TABLE
VALUES(2,'USER02','PASS02','김창진','여');

--무결성 제약 조건에 위배됩니다.
INSERT INTO USER_PK_TABLE
VALUES(1,'USER03','PASS03','박창진','여');
-- NULL을 PRIMARY키에 삽입불가
INSERT INTO USER_PK_TABLE
VALUES(NULL,'USER03','PASS03','박창진','여');

SELECT* FROM USER_PK_TABLE;
--기본키 제약조건을 설정하면 NOT NULL과 UNIQUE가 함께 설정 된다.


--기본키 제약조건을 여러 컬럼에 적용하기
CREATE TABLE USER_PK_TABLE2(
	USER_NO NUMBER,
	USER_ID VARCHAR2(20) UNIQUE NOT NULL,
	USER_PWD VARCHAR2(30) NOT NULL,
	USER_NAME VARCHAR2(15) NOT NULL,
	GENDER VARCHAR2(3) CHECK(GENDER IN ('남','여')),
	CONSTRAINT PK_USER_NO2 PRIMARY KEY(USER_NO, USER_ID)
);

-- 1, USER01 => 성공
-- 2, USER02 => 성공
-- 1, USER03 => 성공
-- 2, USER01 => 실패!

-- MEMBER 테이블을 생성
-- 사용자 정보를 받아 저장할 수 있는 테이블 객체를 생성 하는데
-- 회원번호는 NUMBER 형태로 기본키 설정,
-- 회원 아이디는 중복 불가에 필수 입력사항,
-- 회원 비밀번호는 필수 입력사항,
-- 회원이름,
-- 성별('F','M')만 입력 받을 수 있게,
-- 회원 연락처
-- 이러한 회원의 정보를 저장할 수 있는 컬럼을 가진 MEMBER 테이블 생성.
-- 컬럼의 크기는 편하신데로, 테이블 생성 후에는 INSERT 5번 이상 진행 후
-- SELECT까지! 확인!
CREATE TABLE MEMBER(
	MEMBER_NO NUMBER PRIMARY KEY,
	MEMBER_ID VARCHAR2(15) UNIQUE NOT NULL,
	MEMBER_PWD VARCHAR2(20) NOT NULL,
	MEMBER_NAME VARCHAR2(15),
	MEMBER_GENDER VARCHAR2(3) CHECK(MEMBER_GENDER IN ('F','M')),
	PHONE VARCHAR2(15)
);


INSERT INTO MEMBER VALUES(1,'USER01','PASS01','이창진','M','01012345678');
INSERT INTO MEMBER VALUES(2,'USER02','PASS01','김창진','F','01012345678');
INSERT INTO MEMBER VALUES(3,'USER03','PASS01','박창진','F','01012345678');
INSERT INTO MEMBER VALUES(4,'USER04','PASS01','정창진','F','01012345678');
INSERT INTO MEMBER VALUES(5,'USER05','PASS01','구창진','M','01012345678');

SELECT* FROM MEMBER;


-- FOREIGN KEY --
-- 외래키, 외부키, 참조키
-- 다른 테이블의 컬럼값을 참조(REFERENCE)하여 
-- 참조하는 테이블 값에 접근
-- FOREIGN KEY 제약조건을 통해 테이블간에 관계(RELATIONSHIP) 형성된다.

-- 컬럼레벨
-- 컬럼명 자료형(길이) [CONSTRAINT 제약조건명] REFERENCES 참조할 테이블명[(참조할 컬럼명)] [삭제옵션]
-- 테이블레벨
-- [CONTRAINT 제약조건명] FOREIGN KEY(적용할컬럼명) REFERENCES 참조할 테이블명[(참조할 컬럼명)] [삭제옵션]
-- 참조할 컬럼명을 생략하면 참조할 테이블의 기본키(PK)를 참조할 컬럼으로 가져온다.
-- 참조하고자 하는 컬럼은 반드시 PK이거나 UNIQUE 제약조건이 걸려 있어야 한다.

DROP TABLE USER_GRADE;
CREATE TABLE USER_GRADE(
	CODE NUMBER PRIMARY KEY,
	NAME VARCHAR2(30) NOT NULL
);

INSERT INTO USER_GRADE VALUES( 1, '일반회원');
INSERT INTO USER_GRADE VALUES( 2, 'VIP');
INSERT INTO USER_GRADE VALUES( 3, 'VVIP');
INSERT INTO USER_GRADE VALUES( 4, 'VVVIP');

SELECT * FROM USER_GRADE;

-- 1 ON DELETE SET NULL
CREATE TABLE USER_FOREIGN_KEY(
	USER_NO NUMBER PRIMARY KEY,
	USER_ID VARCHAR2(20),
	USER_PWD VARCHAR2(15),
	USER_NAME VARCHAR2(15),
	GRADE_CODE NUMBER,
	CONSTRAINT FK_GRADE_CODE FOREIGN KEY(GRADE_CODE) 
	REFERENCES USER_GRADE(CODE) ON DELETE SET NULL
);


SELECT * FROM USER_FOREIGN_KEY;

INSERT INTO USER_FOREIGN_KEY VALUES(1,'123','321','홍길동',2);
INSERT INTO USER_FOREIGN_KEY VALUES(2,'ABC','ABC1','김길동',4);
INSERT INTO USER_FOREIGN_KEY VALUES(3,'456','654','박길동',1);
INSERT INTO USER_FOREIGN_KEY VALUES(4,'DEF','PASS1','최길동',3);
INSERT INTO USER_FOREIGN_KEY VALUES(5,'QWER','REWQ','정길동',1);

SELECT *
FROM USER_FOREIGN_KEY
LEFT JOIN USER_GRADE ON(GRADE_CODE = CODE);

-- 무결성 제약조건이 위배되었습니다
DELETE FROM USER_GRADE WHERE CODE=4;
INSERT INTO USER_FOREIGN_KEY VALUES(6,'QQQ','WWWW','조길동',10);

--참조하고 있는 원본 테이블의(부모) 컬럼 값이 삭제 될때
-- 참조한 값을 어떻게 처리 할 것인지 설정하는 옵션
-- 일반적으로 참조하는 원본 컬럼의 내용을 삭제 하려 한다면
-- 외래키로 사용 중인 자식 컬럼이 존재 할때는 함부로 삭제 불가능 하다.
-- 함부로 삭제 할 수 없다. 이를 변경하기 위한 옵션

-- 1. 부모 컬럼을 삭제 할때 자식을 NULL로 변경 하기.
-- ON DELETE SET NULL
-- 2. 부모 컬럼을 삭제할 때 관련된 자식도 함께 삭제
-- ON DELETE CASCADE

SELECT * FROM USER_FOREIGN_KEY;
SELECT * FROM USER_GRADE;

DROP TABLE USER_GRADE;
DROP TABLE USER_FOREIGN_KEY;


--2 ON DELETE CASCADE
-- 자식 테이블의 데이터도 삭제.
DROP TABLE USER_FOREIGN_KEY;
CREATE TABLE USER_FOREIGN_KEY(
	USER_NO NUMBER PRIMARY KEY,
	USER_ID VARCHAR2(20),
	USER_PWD VARCHAR2(15),
	USER_NAME VARCHAR2(15),
	GRADE_CODE NUMBER,
	CONSTRAINT FK_GRADE_CODE FOREIGN KEY(GRADE_CODE) 
	REFERENCES USER_GRADE(CODE) ON DELETE CASCADE
);


SELECT * FROM USER_FOREIGN_KEY;

INSERT INTO USER_FOREIGN_KEY VALUES(1,'123','321','홍길동',2);
INSERT INTO USER_FOREIGN_KEY VALUES(2,'ABC','ABC1','김길동',4);
INSERT INTO USER_FOREIGN_KEY VALUES(3,'456','654','박길동',1);
INSERT INTO USER_FOREIGN_KEY VALUES(4,'DEF','PASS1','최길동',3);
INSERT INTO USER_FOREIGN_KEY VALUES(5,'QWER','REWQ','정길동',1);

DELETE FROM USER_GRADE
WHERE CODE=1;

SELECT* FROM USER_GRADE;
SELECT* FROM USER_FOREIGN_KEY;


-- SUBQUERY를 활용하여 테이블 만들기

CREATE TABLE EMP_COPY
AS SELECT * FROM EMPLOYEE;

SELECT * FROM EMP_COPY;

DROP TABLE EMP_COPY;

CREATE TABLE EMP_COPY
AS SELECT EMP_ID,EMP_NAME FROM EMPLOYEE WHERE JOB_CODE='J2';

SELECT * FROM EMP_COPY;

-- 테이블의 형식만 복사하기
-- 값을 제외한 형식 복사
CREATE TABLE EMP_COPY2
AS SELECT*
	FROM EMPLOYEE
	WHERE 1=0;
DROP TABLE EMP_COPY2;
SELECT * FROM EMP_COPY2;

-- 서브 쿼리를 이용한 특정 컬럼 복사
CREATE TABLE EMP_COPY3
AS SELECT EMP_ID, EMP_NAME,SALARY,
		  DEPT_CODE "DEPT", JOB_CODE "JOB"
		  FROM EMPLOYEE;
SELECT*FROM EMP_COPY3;
SELECT DEPT,JOB FROM EMP_COPY3;

-- 각 컬럼에 값을 기록하지 않을 경우 기본값 설정하기
CREATE TABLE DEFAULT_TABLE(
	DATA_COL1 VARCHAR2(30) DEFAULT '없음',
	DATA_COL2 DATE DEFAULT CURRENT_DATE
);

--NULL 값이 저장
INSERT INTO DEFAULT_TABLE VALUES(NULL, NULL);
-- 기본 값으로 저장
INSERT INTO DEFAULT_TABLE VALUES(DEFAULT,DEFAULT);

SELECT * FROM DEFAULT_TABLE;


-- ALTER 사용하여 제약조건을 테이블 생성 후 추가
-- DDL

-- ALTER TABLE 테이블명 ADD PRIMARY KEY(컬럼명)
-- ALTER TABLE 테이블명 ADD FOREIGN KEY(컬럼명)  REFERENCES 참조할 테이블명(컬럼명)
-- ALTER TABLE 테이블명 ADD UNIQUE(컬럼명)
-- ALTER TABLE 테이블명 ADD CHECK(조건식)
-- ALTER TABLE 테이블명 MODIFY 컬럼명 NOT NULL

ALTER TABLE EMPLOYEE ADD FOREIGN KEY(DEPT_CODE) REFERENCES DEPARTMENT;

-- 제약조건을 중간에 변경 할 경우 이미 저장한 값 등을 파악하여 제약조건에 위배되지 않는지 확인 해야 한다.
-- ALTER TABLE EMPLOYEE ADD FOREIGN KEY(MANAGER_ID) REFERENCES EMPLOYEE;

ALTER TABLE EMPLOYEE ADD FOREIGN KEY(JOB_CODE) REFERENCES JOB;
ALTER TABLE EMPLOYEE ADD FOREIGN KEY(SAL_LEVEL) REFERENCES SAL_GRADE;

ALTER TABLE EMPLOYEE ADD CHECK(ENT_YN IN('Y','N'));
ALTER TABLE EMPLOYEE ADD CHECK(SALARY > 0);
ALTER TABLE EMPLOYEE ADD UNIQUE(EMP_NO);

ALTER TABLE DEPARTMENT ADD FOREIGN KEY(LOCATION_ID) REFERENCES LOCATION;
ALTER TABLE LOCATION ADD FOREIGN KEY(NATIONAL_CODE) REFERENCES NATIONAL;

SELECT*
FROM USER_CONSTRAINTS C1
JOIN USER_CONS_COLUMNS C2 ON(C1.TABLE_NAME = C2.TABLE_NAME AND C1.CONSTRAINT_NAME = C2.CONSTRAINT_NAME)
WHERE C1.TABLE_NAME IN('EMPLOYEE','DEPARTMENT','LOCATION');




















